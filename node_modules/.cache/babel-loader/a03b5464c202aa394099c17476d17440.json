{"ast":null,"code":"import _asyncToGenerator from \"/Users/mac/Documents/GitHub/inner-web/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/mac/Documents/GitHub/inner-web/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/mac/Documents/GitHub/inner-web/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/mac/Documents/GitHub/inner-web/node_modules/@babel/runtime/regenerator/index.js\";\nimport { useEffect, useReducer, useRef } from 'react';\n\nfunction useFetch(url, options) {\n  var cache = useRef({});\n  var cancelRequest = useRef(false);\n  var initialState = {\n    error: undefined,\n    data: undefined\n  };\n\n  var fetchReducer = function fetchReducer(state, action) {\n    switch (action.type) {\n      case 'loading':\n        return _objectSpread({}, initialState);\n\n      case 'fetched':\n        return _objectSpread(_objectSpread({}, initialState), {}, {\n          data: action.payload\n        });\n\n      case 'error':\n        return _objectSpread(_objectSpread({}, initialState), {}, {\n          error: action.payload\n        });\n\n      default:\n        return state;\n    }\n  };\n\n  var _useReducer = useReducer(fetchReducer, initialState),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      state = _useReducer2[0],\n      dispatch = _useReducer2[1];\n\n  useEffect(function () {\n    if (!url) return;\n\n    var fetchData = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var response, data;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                dispatch({\n                  type: 'loading'\n                });\n\n                if (!cache.current[url]) {\n                  _context.next = 4;\n                  break;\n                }\n\n                dispatch({\n                  type: 'fetched',\n                  payload: cache.current[url]\n                });\n                return _context.abrupt(\"return\");\n\n              case 4:\n                _context.prev = 4;\n                _context.next = 7;\n                return fetch(url, options);\n\n              case 7:\n                response = _context.sent;\n\n                if (response.ok) {\n                  _context.next = 10;\n                  break;\n                }\n\n                throw new Error(response.statusText);\n\n              case 10:\n                _context.next = 12;\n                return response.json();\n\n              case 12:\n                data = _context.sent;\n                cache.current[url] = data;\n\n                if (!cancelRequest.current) {\n                  _context.next = 16;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 16:\n                dispatch({\n                  type: 'fetched',\n                  payload: data\n                });\n                _context.next = 24;\n                break;\n\n              case 19:\n                _context.prev = 19;\n                _context.t0 = _context[\"catch\"](4);\n\n                if (!cancelRequest.current) {\n                  _context.next = 23;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 23:\n                dispatch({\n                  type: 'error',\n                  payload: _context.t0\n                });\n\n              case 24:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[4, 19]]);\n      }));\n\n      return function fetchData() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    void fetchData();\n    return function () {\n      cancelRequest.current = true;\n    };\n  }, [url]);\n  return state;\n}\n\nexport default useFetch;","map":{"version":3,"mappings":";;;;AAAA,SAASA,SAAT,EAAoBC,UAApB,EAAgCC,MAAhC,QAA8C,OAA9C;;AAeA,SAASC,QAAT,CAA+BC,GAA/B,EAA6CC,OAA7C,EAAkE;AAChE,MAAMC,KAAK,GAAGJ,MAAM,CAAW,EAAX,CAApB;AAGA,MAAMK,aAAa,GAAGL,MAAM,CAAU,KAAV,CAA5B;AAEA,MAAMM,YAAY,GAAa;AAC7BC,SAAK,EAAEC,SADsB;AAE7BC,QAAI,EAAED;AAFuB,GAA/B;;AAMA,MAAME,YAAY,GAAG,SAAfA,YAAe,CAACC,KAAD,EAAkBC,MAAlB,EAAiD;AACpE,YAAQA,MAAM,CAACC,IAAf;AACE,WAAK,SAAL;AACE,iCAAYP,YAAZ;;AACF,WAAK,SAAL;AACE,+CAAYA,YAAZ;AAA0BG,cAAI,EAAEG,MAAM,CAACE;AAAvC;;AACF,WAAK,OAAL;AACE,+CAAYR,YAAZ;AAA0BC,eAAK,EAAEK,MAAM,CAACE;AAAxC;;AACF;AACE,eAAOH,KAAP;AARJ;AAUD,GAXD;;AAaA,oBAA0BZ,UAAU,CAACW,YAAD,EAAeJ,YAAf,CAApC;AAAA;AAAA,MAAOK,KAAP;AAAA,MAAcI,QAAd;;AAEAjB,WAAS,CAAC,YAAK;AAEb,QAAI,CAACI,GAAL,EAAU;;AAEV,QAAMc,SAAS;AAAA,0EAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAChBD,wBAAQ,CAAC;AAAEF,sBAAI,EAAE;AAAR,iBAAD,CAAR;;AADgB,qBAIZT,KAAK,CAACa,OAAN,CAAcf,GAAd,CAJY;AAAA;AAAA;AAAA;;AAKda,wBAAQ,CAAC;AAAEF,sBAAI,EAAE,SAAR;AAAmBC,yBAAO,EAAEV,KAAK,CAACa,OAAN,CAAcf,GAAd;AAA5B,iBAAD,CAAR;AALc;;AAAA;AAAA;AAAA;AAAA,uBAUSgB,KAAK,CAAChB,GAAD,EAAMC,OAAN,CAVd;;AAAA;AAURgB,wBAVQ;;AAAA,oBAWTA,QAAQ,CAACC,EAXA;AAAA;AAAA;AAAA;;AAAA,sBAYN,IAAIC,KAAJ,CAAUF,QAAQ,CAACG,UAAnB,CAZM;;AAAA;AAAA;AAAA,uBAeMH,QAAQ,CAACI,IAAT,EAfN;;AAAA;AAeRd,oBAfQ;AAgBdL,qBAAK,CAACa,OAAN,CAAcf,GAAd,IAAqBO,IAArB;;AAhBc,qBAiBVJ,aAAa,CAACY,OAjBJ;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAmBdF,wBAAQ,CAAC;AAAEF,sBAAI,EAAE,SAAR;AAAmBC,yBAAO,EAAEL;AAA5B,iBAAD,CAAR;AAnBc;AAAA;;AAAA;AAAA;AAAA;;AAAA,qBAqBVJ,aAAa,CAACY,OArBJ;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAuBdF,wBAAQ,CAAC;AAAEF,sBAAI,EAAE,OAAR;AAAiBC,yBAAO;AAAxB,iBAAD,CAAR;;AAvBc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAH;;AAAA,sBAATE,SAAS;AAAA;AAAA;AAAA,OAAf;;AA2BA,SAAKA,SAAS,EAAd;AAIA,WAAO,YAAK;AACVX,mBAAa,CAACY,OAAd,GAAwB,IAAxB;AACD,KAFD;AAID,GAvCQ,EAuCN,CAACf,GAAD,CAvCM,CAAT;AAyCA,SAAOS,KAAP;AACD;;AAED,eAAeV,QAAf","names":["useEffect","useReducer","useRef","useFetch","url","options","cache","cancelRequest","initialState","error","undefined","data","fetchReducer","state","action","type","payload","dispatch","fetchData","current","fetch","response","ok","Error","statusText","json"],"sources":["/Users/mac/Documents/GitHub/inner-web/node_modules/usehooks-ts/src/useFetch/useFetch.ts"],"sourcesContent":["import { useEffect, useReducer, useRef } from 'react'\n\ninterface State<T> {\n  data?: T\n  error?: Error\n}\n\ntype Cache<T> = { [url: string]: T }\n\n// discriminated union type\ntype Action<T> =\n  | { type: 'loading' }\n  | { type: 'fetched'; payload: T }\n  | { type: 'error'; payload: Error }\n\nfunction useFetch<T = unknown>(url?: string, options?: RequestInit): State<T> {\n  const cache = useRef<Cache<T>>({})\n\n  // Used to prevent state update if the component is unmounted\n  const cancelRequest = useRef<boolean>(false)\n\n  const initialState: State<T> = {\n    error: undefined,\n    data: undefined,\n  }\n\n  // Keep state logic separated\n  const fetchReducer = (state: State<T>, action: Action<T>): State<T> => {\n    switch (action.type) {\n      case 'loading':\n        return { ...initialState }\n      case 'fetched':\n        return { ...initialState, data: action.payload }\n      case 'error':\n        return { ...initialState, error: action.payload }\n      default:\n        return state\n    }\n  }\n\n  const [state, dispatch] = useReducer(fetchReducer, initialState)\n\n  useEffect(() => {\n    // Do nothing if the url is not given\n    if (!url) return\n\n    const fetchData = async () => {\n      dispatch({ type: 'loading' })\n\n      // If a cache exists for this url, return it\n      if (cache.current[url]) {\n        dispatch({ type: 'fetched', payload: cache.current[url] })\n        return\n      }\n\n      try {\n        const response = await fetch(url, options)\n        if (!response.ok) {\n          throw new Error(response.statusText)\n        }\n\n        const data = (await response.json()) as T\n        cache.current[url] = data\n        if (cancelRequest.current) return\n\n        dispatch({ type: 'fetched', payload: data })\n      } catch (error) {\n        if (cancelRequest.current) return\n\n        dispatch({ type: 'error', payload: error as Error })\n      }\n    }\n\n    void fetchData()\n\n    // Use the cleanup function for avoiding a possibly...\n    // ...state update after the component was unmounted\n    return () => {\n      cancelRequest.current = true\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [url])\n\n  return state\n}\n\nexport default useFetch\n"]},"metadata":{},"sourceType":"module"}